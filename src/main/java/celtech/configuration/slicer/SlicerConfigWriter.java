package celtech.configuration.slicer;

import celtech.Lookup;
import celtech.configuration.ApplicationConfiguration;
import celtech.configuration.SlicerType;
import celtech.configuration.fileRepresentation.SlicerMappingData;
import celtech.configuration.fileRepresentation.SlicerParameters;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import libertysystems.stenographer.Stenographer;
import libertysystems.stenographer.StenographerFactory;

/**
 *
 * @author Ian
 */
public abstract class SlicerConfigWriter
{

    private final Stenographer steno = StenographerFactory.getStenographer(Slic3rConfigWriter.class.getName());
    SlicerType slicerType = null;
    private SimpleDateFormat dateFormatter = null;
    protected NumberFormat threeDPformatter;

    private float centreX = 0;
    private float centreY = 0;

    private final String parameterDivider = ":";
    private final String queryDivider = "?";
    private final String optionalDivider = "->";

    public SlicerConfigWriter()
    {
        dateFormatter = new SimpleDateFormat("EEE d MMM y HH:mm:ss", Locale.UK);
        threeDPformatter = DecimalFormat.getNumberInstance(Locale.UK);
        threeDPformatter.setMaximumFractionDigits(3);
        threeDPformatter.setGroupingUsed(false);
    }

    /**
     *
     * @param profileData
     * @param destinationFile
     */
    public final void generateConfigForSlicer(SlicerParameters profileData, String destinationFile)
    {
        File outputFile = new File(destinationFile);
        FileWriter writer = null;

        try
        {
            writer = new FileWriter(outputFile);

            SlicerMappingData mappingData = Lookup.getSlicerMappings().getMappings().get(slicerType);

            String dateString = dateFormatter.format(new Date());
            writer.write("#Slicer configuration generated by AutoMaker on " + dateString + "\n");
            writer.write(
                "#"
                + ApplicationConfiguration.getApplicationName()
                + " version "
                + ApplicationConfiguration.getApplicationVersion()
                + "\n");
            writer.write("#Slicer type " + slicerType.name() + "\n");
            writer.write("#Profile " + profileData.getProfileName() + "\n");
            writer.write("#\n");

            outputFilamentDiameter(writer, ApplicationConfiguration.filamentDiameterToYieldVolumetricExtrusion);

            outputPrintCentre(writer, centreX, centreY);

            //Process the defaults
            for (String defaultData : mappingData.getDefaults())
            {
                // This is a default value for the slicer - don't look it up.
                String[] valueElements = defaultData.split(":");
                String variableName = valueElements[0];

                String value = "";
                if (valueElements.length == 2)
                {
                    value = valueElements[1];
                }

                steno.info("Writing default " + variableName);
                outputLine(writer, variableName, value);
            }

            for (Map.Entry<String, String> entry : mappingData.getMappingData().entrySet())
            {
                String methodName = entry.getKey();
                String targetVariableName = extractTargetVariableName(entry.getValue());
                steno.info("Processing method: " + methodName + " and variable : " + targetVariableName);

                methodName = "get" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1, methodName.length());
                Method getMethod = getVariableMethod(methodName);

                if (getMethod != null)
                {
                    try
                    {
                        steno.debug("Writing " + methodName + " : " + targetVariableName);

                        Class<?> returnTypeClass = getMethod.getReturnType();

                        if (returnTypeClass.equals(boolean.class))
                        {
                            boolean value = (boolean) getMethod.invoke(profileData);
                            outputLine(writer, targetVariableName, value);
                        } else if (returnTypeClass.equals(int.class))
                        {
                            int value = (int) getMethod.invoke(profileData);
                            outputLine(writer, targetVariableName, (int) applyValue(profileData, value, entry.getValue()));
                        } else if (returnTypeClass.equals(float.class))
                        {
                            float value = (float) getMethod.invoke(profileData);
                            outputLine(writer, targetVariableName, applyValue(profileData, value, entry.getValue()));
                        } else if (returnTypeClass.equals(String.class))
                        {
                            String value = (String) getMethod.invoke(profileData);
                            outputLine(writer, targetVariableName, value);
                        } else if (returnTypeClass.equals(SlicerType.class))
                        {
                            SlicerType value = (SlicerType) getMethod.invoke(profileData);
                            outputLine(writer, targetVariableName, value);
                        } else if (returnTypeClass.equals(FillPattern.class))
                        {
                            FillPattern value = (FillPattern) getMethod.invoke(profileData);
                            outputLine(writer, targetVariableName, value);
                        } else if (returnTypeClass.equals(SupportPattern.class))
                        {
                            SupportPattern value = (SupportPattern) getMethod.invoke(profileData);
                            outputLine(writer, targetVariableName, value);
                        } else
                        {
                            steno.error("Got unknown return type: " + returnTypeClass.getName());
                        }

                    } catch (IllegalAccessException ex)
                    {
                        steno.error("Illegal access exception when retrieving from " + methodName);
                    } catch (InvocationTargetException ex)
                    {
                        steno.error("Invocation target exception when retrieving from " + methodName);
                    }
                }
            }
        } catch (FileNotFoundException ex)
        {
            steno.error("Couldn't open slic3r settings file for writing - " + destinationFile + " : " + ex.getMessage());
        } catch (IOException ex)
        {
            steno.error("IO Exception whilst writing slic3r settings - " + destinationFile + " : " + ex.getMessage());
        } finally
        {
            if (writer != null)
            {
                try
                {
                    writer.close();
                } catch (IOException ex)
                {
                    steno.error("Failed to close configuration file " + outputFile.getName());
                }
            }
        }
    }

    /**
     *
     * @param x
     * @param y
     */
    public void setPrintCentre(float x, float y)
    {
        centreX = x;
        centreY = y;
    }

    protected abstract void outputLine(FileWriter writer, String variableName, boolean value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, int value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, float value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, String value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, SlicerType value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, FillPattern value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, SupportPattern value) throws IOException;

    protected abstract void outputPrintCentre(FileWriter writer, float centreX, float centreY) throws IOException;

    protected abstract void outputFilamentDiameter(FileWriter writer, float diameter) throws IOException;

    private float applyValue(SlicerParameters profileData, float value, String operationString)
    {
        float resultingValue = value;
        boolean okToProcess = false;

        if (operationString.contains(parameterDivider))
        {
            String[] valueElements = operationString.split(parameterDivider);

            boolean doneProcessing = false;

            if (valueElements.length > 1)
            {
                for (int elementCounter = 1; elementCounter < valueElements.length; elementCounter++)
                {
                    String operation = valueElements[elementCounter];

                    if (operation.contains(queryDivider))
                    {
                        String[] optionalAssignmentString = operation.substring(1).split(optionalDivider);
                        if (optionalAssignmentString.length == 2)
                        {
                            try
                            {
                                float valueToCheckFor = Float.valueOf(optionalAssignmentString[0]);
                                float optionalAssignmentValue = Float.valueOf(optionalAssignmentString[1]);

                                if (value == valueToCheckFor)
                                {
                                    resultingValue = optionalAssignmentValue;
                                    doneProcessing = true;
                                }
                            } catch (NumberFormatException ex)
                            {
                                // Failed to process...
                                steno.warning("Couldn't process optional slicer mapping: " + operation);
                            }
                        } else
                        {
                            steno.warning("Erroneous optional slicer mapping: " + operation);
                        }
                    }

                    if (!doneProcessing)
                    {
                        String operator = operation.substring(0, 1);
                        String variable = operation.substring(1);

                        Method getMethod = getVariableMethod(variable);

                        float variableValue = 0;

                        if (getMethod != null)
                        {
                            // Found a get - must be a variable that we can use...

                            try
                            {
                                variableValue = (float) getMethod.invoke(profileData);
                                okToProcess = true;
                            } catch (IllegalAccessException | InvocationTargetException ex)
                            {
                                steno.warning("Failed to get value for " + variable);
                            }
                        } else
                        {
                            // We should have a number instead
                            try
                            {
                                variableValue = Float.valueOf(variable);
                                okToProcess = true;
                            } catch (NumberFormatException ex)
                            {
                                steno.warning("Failed to get process numeric value " + variable);
                            }
                        }

                        if (okToProcess)
                        {
                            switch (operator)
                            {
                                case "*":
                                    resultingValue = resultingValue * variableValue;
                                    break;
                                case "/":
                                    resultingValue = resultingValue / variableValue;
                                    break;
                                case "+":
                                    resultingValue = resultingValue + variableValue;
                                    break;
                                case "-":
                                    resultingValue = resultingValue - variableValue;
                                    break;
                            }
                        }
                    }
                }
            }
        }

        return resultingValue;
    }

    private String extractTargetVariableName(String value)
    {
        String targetVariableName = value;

        if (value.contains(":"))
        {
            String[] elements = value.split(":");
            targetVariableName = elements[0];
        }

        return targetVariableName;
    }

    private Method getVariableMethod(String methodName)
    {
        Method foundMethod = null;

        try
        {
            foundMethod = SlicerParameters.class.getMethod(methodName, null);
        } catch (NoSuchMethodException ex)
        {
            steno.warning("Failed to get method for " + methodName);
        }

        return foundMethod;
    }
}
