package celtech.configuration.slicer;

import celtech.Lookup;
import celtech.configuration.ApplicationConfiguration;
import celtech.configuration.SlicerType;
import celtech.configuration.fileRepresentation.SlicerParameters;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import libertysystems.stenographer.Stenographer;
import libertysystems.stenographer.StenographerFactory;
import org.apache.commons.io.FileUtils;

/**
 *
 * @author Ian
 */
public abstract class SlicerConfigWriter
{

    private final Stenographer steno = StenographerFactory.getStenographer(Slic3rConfigWriter.class.getName());
    SlicerType slicerType = null;
    private SimpleDateFormat dateFormatter = null;
    protected NumberFormat threeDPformatter;

    private float centreX = 0;
    private float centreY = 0;

    private final String defaultFlag = "D:";

    public SlicerConfigWriter()
    {
        dateFormatter = new SimpleDateFormat("EEE d MMM y HH:mm:ss", Locale.UK);
        threeDPformatter = DecimalFormat.getNumberInstance(Locale.UK);
        threeDPformatter.setMaximumFractionDigits(3);
        threeDPformatter.setGroupingUsed(false);
    }

    /**
     *
     * @param profileData
     * @param destinationFile
     */
    public final void generateConfigForSlicer(SlicerParameters profileData, String destinationFile)
    {
        File outputFile = new File(destinationFile);
        try
        {
            Map<String, String> slicerMappings = Lookup.getSlicerMappings().getMappings().get(slicerType);

            String dateString = dateFormatter.format(new Date());
            FileUtils.writeStringToFile(outputFile, "#Slicer configuration generated by AutoMaker on " + dateString + "\n", false);
            FileUtils.writeStringToFile(outputFile,
                                        "#"
                                        + ApplicationConfiguration.getApplicationName()
                                        + " version "
                                        + ApplicationConfiguration.getApplicationVersion()
                                        + "\n", true);
            FileUtils.writeStringToFile(outputFile, "#Slicer type " + slicerType.name() + "\n", true);
            FileUtils.writeStringToFile(outputFile, "#Profile " + profileData.getProfileName() + "\n", true);
            FileUtils.writeStringToFile(outputFile, "#\n", true);
            
            outputFilamentDiameter(outputFile, ApplicationConfiguration.filamentDiameterToYieldVolumetricExtrusion);
            
            outputPrintCentre(outputFile, centreX, centreY);

            for (Map.Entry<String, String> entry : slicerMappings.entrySet())
            {
                String methodName = entry.getKey();
                String targetVariableName = entry.getValue();

                float scale = 1;
                if (targetVariableName.contains(":"))
                {
                    String[] valueElements = targetVariableName.split(":");
                    targetVariableName = valueElements[0];
                    scale = Float.valueOf(valueElements[1]);
                }

                if (methodName.startsWith(defaultFlag))
                {
                    // This is a default value for the slicer - don't look it up.
                    String value = methodName.replaceFirst(defaultFlag, "");
                    steno.info("Writing default " + targetVariableName);
                    outputLine(outputFile, targetVariableName, value);
                } else
                {                    
                    methodName = "get" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1, methodName.length());

                    try
                    {
                        steno.debug("Writing " + methodName + " : " + targetVariableName);
                        Method getMethod = SlicerParameters.class.getMethod(methodName, null);

                        Class<?> returnTypeClass = getMethod.getReturnType();

                        if (returnTypeClass.equals(boolean.class))
                        {
                            boolean value = (boolean) getMethod.invoke(profileData);
                            outputLine(outputFile, targetVariableName, value);
                        } else if (returnTypeClass.equals(int.class))
                        {
                            int value = (int) getMethod.invoke(profileData);
                            outputLine(outputFile, targetVariableName, value * scale);
                        } else if (returnTypeClass.equals(float.class))
                        {
                            float value = (float) getMethod.invoke(profileData);
                            outputLine(outputFile, targetVariableName, value * scale);
                        } else if (returnTypeClass.equals(String.class))
                        {
                            String value = (String) getMethod.invoke(profileData);
                            outputLine(outputFile, targetVariableName, value);
                        } else if (returnTypeClass.equals(SlicerType.class))
                        {
                            SlicerType value = (SlicerType) getMethod.invoke(profileData);
                            outputLine(outputFile, targetVariableName, value);
                        } else if (returnTypeClass.equals(FillPattern.class))
                        {
                            FillPattern value = (FillPattern) getMethod.invoke(profileData);
                            outputLine(outputFile, targetVariableName, value);
                        } else if (returnTypeClass.equals(SupportPattern.class))
                        {
                            SupportPattern value = (SupportPattern) getMethod.invoke(profileData);
                            outputLine(outputFile, targetVariableName, value);
                        } else
                        {
                            steno.error("Got unknown return type: " + returnTypeClass.getName());
                        }

                    } catch (NoSuchMethodException ex)
                    {
                        steno.error("Unable to find " + methodName);
                    } catch (IllegalAccessException ex)
                    {
                        steno.error("Illegal access exception when retrieving from " + methodName);
                    } catch (InvocationTargetException ex)
                    {
                        steno.error("Invocation target exception when retrieving from " + methodName);
                    }
                }
            }
        } catch (FileNotFoundException ex)
        {
            steno.error("Couldn't open slic3r settings file for writing - " + destinationFile + " : " + ex.getMessage());
        } catch (IOException ex)
        {
            steno.error("IO Exception whilst writing slic3r settings - " + destinationFile + " : " + ex.getMessage());
        }
    }

    /**
     *
     * @param x
     * @param y
     */
    public void setPrintCentre(float x, float y)
    {
        centreX = x;
        centreY = y;
    }

    protected abstract void outputLine(File outputFile, String variableName, boolean value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, int value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, float value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, String value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, SlicerType value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, FillPattern value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, SupportPattern value) throws IOException;
    
    protected abstract void outputPrintCentre(File outputFile, float centreX, float centreY) throws IOException;

    protected abstract void outputFilamentDiameter(File outputFile, float diameter) throws IOException;
}
