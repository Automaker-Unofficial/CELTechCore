package celtech.configuration.slicer;

import celtech.Lookup;
import celtech.configuration.ApplicationConfiguration;
import celtech.configuration.SlicerType;
import celtech.configuration.fileRepresentation.SlicerParameters;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import libertysystems.stenographer.Stenographer;
import libertysystems.stenographer.StenographerFactory;
import org.apache.commons.io.FileUtils;

/**
 *
 * @author Ian
 */
public abstract class SlicerConfigWriter
{

    private final Stenographer steno = StenographerFactory.getStenographer(Slic3rConfigWriter.class.getName());
    SlicerType slicerType = null;
    private SimpleDateFormat dateFormatter = null;
    protected NumberFormat threeDPformatter;

    private double centreX = 0;
    private double centreY = 0;

    public SlicerConfigWriter()
    {
        dateFormatter = new SimpleDateFormat("EEE d MMM y HH:mm:ss", Locale.UK);
        threeDPformatter = DecimalFormat.getNumberInstance(Locale.UK);
        threeDPformatter.setMaximumFractionDigits(3);
        threeDPformatter.setGroupingUsed(false);
    }

    /**
     *
     * @param profileData
     * @param destinationFile
     */
    public final void generateConfigForSlicer(SlicerParameters profileData, String destinationFile)
    {
        File outputFile = new File(destinationFile);
        try
        {
            Map<String, String> slicerMappings = Lookup.getSlicerMappings().getMappings().get(slicerType);

            String dateString = dateFormatter.format(new Date());
            FileUtils.writeStringToFile(outputFile, "#Slicer configuration generated by AutoMaker on " + dateString + "\n", false);
            FileUtils.writeStringToFile(outputFile,
                                        "#"
                                        + ApplicationConfiguration.getApplicationName()
                                        + " version "
                                        + ApplicationConfiguration.getApplicationVersion()
                                        + "\n", true);
            FileUtils.writeStringToFile(outputFile, "#Slicer type " + slicerType.name() + "\n", true);
            FileUtils.writeStringToFile(outputFile, "#Profile " + profileData.getProfileName() + "\n", true);
            FileUtils.writeStringToFile(outputFile, "#\n", true);

//            outputLine(outputFile, "print_center", centreX + "," + centreY);
            for (Map.Entry<String, String> entry : slicerMappings.entrySet())
            {
                String methodName = entry.getKey();
                methodName = "get" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1, methodName.length());
                
                String targetVariableName = entry.getValue();
                float scale = 0;
                if (targetVariableName.contains(":"))
                {
                    String[] valueElements = targetVariableName.split(":");
                    targetVariableName = valueElements[0];
                    scale = Float.valueOf(valueElements[1]);
                }

                try
                {
                    Method getMethod = SlicerParameters.class.getMethod(methodName, null);

                    Class<?> returnTypeClass = getMethod.getReturnType();

                    if (returnTypeClass.equals(boolean.class))
                    {
                        steno.info("Got boolean");
                        boolean value = (boolean) getMethod.invoke(profileData);
                        outputLine(outputFile, targetVariableName, value);
                    } else if (returnTypeClass.equals(int.class))
                    {
                        steno.info("Got int");
                        int value = (int) getMethod.invoke(profileData);
                        outputLine(outputFile, targetVariableName, value * scale);
                    } else if (returnTypeClass.equals(float.class))
                    {
                        steno.info("Got float");
                        float value = (float) getMethod.invoke(profileData);
                        outputLine(outputFile, targetVariableName, value * scale);
                    } else if (returnTypeClass.equals(String.class))
                    {
                        steno.info("Got string");
                        String value = (String) getMethod.invoke(profileData);
                        outputLine(outputFile, targetVariableName, value);
                    } else if (returnTypeClass.equals(SlicerType.class))
                    {
                        steno.info("Got slicer type");
                        SlicerType value = (SlicerType) getMethod.invoke(profileData);
                        outputLine(outputFile, targetVariableName, value);
                    } else if (returnTypeClass.equals(FillPattern.class))
                    {
                        steno.info("Got fill pattern");
                        FillPattern value = (FillPattern) getMethod.invoke(profileData);
                        outputLine(outputFile, targetVariableName, value);
                    } else if (returnTypeClass.equals(SupportPattern.class))
                    {
                        steno.info("Got support pattern");
                        SupportPattern value = (SupportPattern) getMethod.invoke(profileData);
                        outputLine(outputFile, targetVariableName, value);
                    } else
                    {
                        steno.error("Got unknown return type: " + returnTypeClass.getName());
                    }

                } catch (NoSuchMethodException ex)
                {
                    steno.error("Unable to find " + methodName);
                } catch (IllegalAccessException ex)
                {
                    steno.error("Illegal access exception when retrieving from " + methodName);
                } catch (InvocationTargetException ex)
                {
                    steno.error("Invocation target exception when retrieving from " + methodName);
                }
            }
//            outputLine(outputFile, "bed_size", "226,160");
//            outputLine(outputFile, "z_offset", "0.0");
//            outputLine(outputFile, "gcode_flavor", "reprap");
//            outputLine(outputFile, "use_relative_e_distances", "1");
//            outputLine(outputFile, "vibration_limit", "0");
//            outputLine("end_gcode", "");
//            outputLine("layer_gcode", "");
//            outputLine("toolchange_gcode", "");
//            outputLine("retract_before_travel", "0");
//            outputLine("retract_length", "0.05");
//            outputLine("retract_length_toolchange", "0");
//            outputLine("retract_lift", "0");
//            outputLine("retract_restart_extra", "0");
//            outputLine("retract_restart_extra_toolchange", "0");
//
//            outputLine("retract_speed", "0");
        } catch (FileNotFoundException ex)
        {
            steno.error("Couldn't open slic3r settings file for writing - " + destinationFile + " : " + ex.getMessage());
        } catch (IOException ex)
        {
            steno.error("IO Exception whilst writing slic3r settings - " + destinationFile + " : " + ex.getMessage());
        }
    }

    /**
     *
     * @param x
     * @param y
     */
    public void setPrintCentre(double x, double y)
    {
        centreX = x;
        centreY = y;
    }

    protected abstract void outputLine(File outputFile, String variableName, boolean value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, int value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, float value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, String value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, SlicerType value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, FillPattern value) throws IOException;

    protected abstract void outputLine(File outputFile, String variableName, SupportPattern value) throws IOException;
}
